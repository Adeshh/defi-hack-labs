//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Attacker} from "../../src/nomad2022/NomadExploit.sol";
import {ForkUtils} from "../utils/ForkUtils.t.sol";

/**
 * @notice Nomad Bridge Exploit Test - August 2022
 * @dev Attack Steps:
 *      1. Replica contract mistakenly initialized with zero hash as acceptable root
 *      2. Attacker crafts message payloads copying from successful exploit transactions
 *      3. Modify recipient address to attacker's address while keeping other fields identical
 *      4. Call Replica.process() with modified payload - zero-root check bypasses proof validation
 *      5. Bridge processes message and transfers tokens to attacker without valid merkle proof
 *      6. Repeat for all tokens available on bridge (WBTC, WETH, USDC, USDT, DAI, FRAX, CQT)
 * @dev Example Transactions:
 *     Replica contract mistakenly initialize : 0x53fd92771d2084a9bf39a6477015ef53b7f116c79d98a21be723d06d79024cad
 *     Attacker send 0.01 WBTC to NomadBridge : 0xed26708a7335116bdb0673f32ace7c2f329fe3cd349e200447210f1721f335f0
 *     NomadBridge Process 100 WBTC to Attacker : 0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460
 */
contract Nomad2022ExploitTest is Test, ForkUtils {
    Attacker public attacker;
    uint256 constant BLOCK_NUMBER = 15259100; // one block before the attack happened

    function setUp() public {
        // Setup fork at one block before attack happened
        string memory rpcUrl = vm.envString("MAINNET_RPC_URL");
        setupFork("nomad2022", rpcUrl, BLOCK_NUMBER - 1);
        selectFork("nomad2022");
        attacker = new Attacker();
    }

    // Test demonstrates funds drained by exploiting uninitialized default zero-root
    function testNomad2022Exploit() public {
        attacker.attack();
    }
}
